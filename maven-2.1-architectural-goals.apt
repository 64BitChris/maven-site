h1. Maven 2.1 

h2. Architectural Goals

h3. POM changes

There are many changes that users have requested in the POM, in addition to wholesale formatting changes. Acommodating these requests is a little tricky
because we need to support different versions simultaneously so that if projecta A builds with 2.0.x, project B can consume the project A POM using 2.1.x.
We just need some way to easy support multiple versions and support mediation between the different versions.

* tags/categories
* dependency excludes && symmetry
* terse attribute based format for the POM
* properties on dependencies
* Specification Dependencies
* Schematron/RelaxNG descriptor for each plugin -- Bryon Jacob proposed a flexible model but XSD is hard to fight here

h3. Embedding

Full embedding of the Maven core is a major feature of the 2.1.x line. The embedder was created primarily for IDE integration and is now being consumed by m2eclipse, Mevenide and IDEA,
but the embedder is also used by the Maven CLI to ensure parity between IDEs and the CLI as much as possible. To understand how the embedder work you can refer to
the [Maven Embedder documentation|http://maven.apache.org/guides/mini/guide-embedding-m2.html].

h3. Custom Components

As discussed in [Substituting of Custom Components|http://docs.codehaus.org/display/MAVEN/Substitution+of+Custom+Maven+Components] we now have two ways
to insert new components into the system.

* Using a directory and specifying it in the Classworlds configuration. Tycho simply has a special set of components that load first before the standard maven components and they override 
  the standard Maven components. Here's the example based on what Tycho is currently doing which allows custom components to be used.
  
{code}
main is org.apache.maven.cli.MavenCli from plexus.core                                                                                                                     
                                                                                                                                                                           
set maven.home default ${user.home}/m2                                                                                                                                     
                                                                                                                                                                           
[plexus.core]                                                                                                                                                              
load ${maven.home}/tycho/*.jar                                                                                                                                             
load ${maven.home}/lib/*.jar 
{code}

* The embedder has the ContainerCustomizer which allow you to inject new component descriptors. This is used in the IDE integration (m2ecipse, Netbeans) for adding
  custom artifact resolvers.

But what we ultimately need for Tycho is a way to dynamically pull in a set of components based on the packaging of a project. In our case with Tycho the packaging is
maven-osgi-bundle and that should kick in the set of components that do builds for OSGi bundles. We also have another use case in Tycho where we are building OSGi bundles
without a POM and actually using a manifest. In this case we need to somehow detect the manifest and then have the custom set of components kick in. In the case of Tycho
we need a different project builder, and artifact resolver.

h3. Mercury
* Sustained connections for transfers (releasing and deploying)
* Artifact Resolution
* Graph-based artifact resolution
* Decouple from Maven's core
* Binary graph that is pre-resolved for a POM
* Conflict resolution is handled by SAT
* PGP support

h3. Model Changes
*  Tags and categorization in the POM
*  Specification dependencies
*  Dependency extensions
  *   Exclude all

h3. Plugin API
* Symmetric output expressions
* Java5 Mojo annotations (Yoav Landman has this working already)
* Clean separation of plugins from reports. It's not good that those are the same thing in the Maven internals.
** Not using concrete XML classes in the Plugin API (Xpp3Dom)

h3. Core Refactorings
* Project Builder
** Maven shared model work: a new way of reading in the models for Maven that is not format dependent in any way i.e. XML, text, YAML, scripts, whatever.
** Pluggable model readers: this could leverage different implementations provided by the shared model work, but we still need a way to detect the type and version
   of the model that we want to consume
** A new terse format that uses attributes
** Automatic parent versioning
** New interpolation component (plexus-interpolation)
** Dynamic build sections ([MNG-3530|http://jira.codehaus.org/browse/MNG-3530])
** Mixin support -- allowing a paramterizable template which can be imported with one line.

* Remove the use of separate plugin repositories. We only need to pull resources from one repository. We started doing this but I've had a couple
   clients that want to separate the tools they use from the code they are developing/building.
* Decouple script-based Plugins from the core -- we are a large part of the way here I need to summarize what was done.
* Remove Settings from the core and make it a user facing configuration (This is primarily done -- jason)
* Have one configuration model for request
* Have one configuration model for session: session takes the request in the constructor and delegates
* Domain logging
* Plugin Manager
**  Removal of the Plugin Registry (done) -- we moved in a direction where people lock down their versions and we've helped by putting default versions
    in the parent POM.
**  Load Plugin dependencies into a separate ClassRealm (done)
**  Plugin Execution Environment: Ability to run any version of a plugin where an environment is created which contains all the
    requirements for a particular version of the Plugin API

* Lifecycle Executor 
**  Queryable Lifecycle
*** The most important change in the embedding environment. You can actually query Maven for the complete execution before it happens. We must know the entire
    model of execution before we execute.
* Custom profile activators -- we don't have a lot of users except the C-based builds so it might be worth while getting rid of it.

h3. Java 5

Java5 annotations for plugins: we have two implementations that have now been merged in plexus-cdc. QDOX 1.7 has now been released so we may want to check the 
source level gleaning again. Jason Dillon has created a working class processing model. We need to deal with Plexus components and Maven plugins.
   
h3. Integration and promotion of scriptable plugins

h3. Backward compatibility
*  Provide layer of adapters for plugin backward compatibility, to avoid immediate necessity to recode entire suite of plugins and reports for 2.1 compat.
  *  Integrity checking
    *  Don't allow builds where versions come from non-project sources
       like local settings and CLI parameters
    *  JC: Don't allow builds where versions come from profiles that
       have to be activated manually
       
h3. Toolchains
* Milos has implemented this and Shane had some feedback so this needs to be linked together

h3. Reporting
* Report Execution Environment: Ability to run any version of a report where an environment is created which contains all the requirements for a particular version of the Report API.
* Decouple the reporting core. We need to get Doxia out of the core. Anything it needs to run should be isolated.
